<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sense - Verbanwendung</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.5;
            max-width: 1200px;
            margin: 0 auto;
            padding: 15px;
            background-color: #f5f5f5;
        }
        
        .container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 15px;
        }
        
        .top-section {
            display: flex;
            gap: 20px;
            margin-bottom: 15px; /* Reduzierter Abstand */
        }
        
        .search-section {
            flex: 1;
        }
        
        .categories-section {
            flex: 1;
        }
        
        header {
            margin-bottom: 8px;
            border-bottom: 1px solid #eee;
            padding-bottom: 4px;
        }
        
        header h1 {
            margin-top: 0; /* Kein Abstand oben */
            margin-bottom: 5px;
            font-size: 18px; /* Noch etwas kleiner */
        }
        
        header p {
            margin-top: 3px;
            margin-bottom: 5px;
            font-size: 13px;
        }
        
        .search-container {
            display: flex;
            gap: 8px;
            margin-bottom: 10px; /* Reduzierter Abstand */
            align-items: center;
            flex-wrap: wrap;
        }
        
        .search-container input {
            flex: 1;
            padding: 6px;
            font-size: 14px;
            border: 2px solid #ddd;
            border-radius: 4px;
            min-width: 150px;
        }
        
        .search-container input:focus {
            border-color: #555;
            outline: none;
        }
        
        .search-hint {
            width: 100%;
            font-size: 11px;
            color: #666;
            margin-top: 2px;
        }
        
        button {
            background-color: #444; /* Dunkelgrau */
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        
        button:hover {
            background-color: #333;
        }
        
        button:disabled {
            background-color: #999;
            cursor: not-allowed;
        }
        
        /* Kategorie-Bereich */
        .categories-title {
            font-size: 16px;
            margin-top: 0; /* Kein Abstand oben für gleiche Höhe */
            margin-bottom: 8px;
            font-weight: bold;
        }
        
        .categories-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
            margin-bottom: 5px; /* Reduzierter Abstand */
        }
        
        .category-button {
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px 7px;
            text-align: left;
            font-size: 12px;
            cursor: pointer;
            color: #333;
        }
        
        .category-button:hover {
            background-color: #e0e0e0;
        }
        
        .category-button.active {
            background-color: #555;
            color: white;
        }
        
        /* Display-Bereich mit fester Höhe für die Erklärung */
        .display-area {
            margin: 8px 0; /* Reduzierter Abstand */
            padding: 12px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border-left: 4px solid #555;
        }
        
        .verb-heading {
            font-size: 20px;
            margin-bottom: 6px;
            color: black;
        }
        
        .verb-info {
            font-size: 13px;
            color: #666;
            margin-bottom: 8px;
        }
        
        .code-display {
            font-family: 'Courier New', monospace;
            background-color: #eef;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        /* Erklärungsbereich mit gleicher Farbe wie unten und fester Höhe */
        .explanation {
            padding: 10px;
            background-color: #e9ecef; /* Grauer Hintergrund wie formula-explanation */
            border-radius: 4px;
            margin-bottom: 8px; /* Reduzierter Abstand */
            font-size: 13px;
            min-height: 80px; /* Reduzierte Mindesthöhe */
            max-height: 120px; /* Maximale Höhe */
            overflow-y: auto; /* Scrollbar wenn nötig */
        }
        
        .alternatives {
            margin-top: 10px;
            border-top: 1px dashed #ccc;
            padding-top: 8px;
        }
        
        .alternative-item {
            margin-bottom: 8px;
            padding: 6px;
            background-color: #f0f0f0;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .suggestion {
            margin-top: 6px;
            padding: 6px;
            background-color: #fff3cd;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .error-message {
            color: #d9534f;
            background-color: #f8d7da;
            padding: 6px;
            border-radius: 4px;
            margin: 6px 0;
            font-size: 12px;
        }
        
        /* Navigationsleiste mit festem Abstand */
        .navigation {
            margin: 10px 0; /* Reduzierter Abstand */
            padding: 8px 0;
            background-color: #f9f9f9;
            border-radius: 8px;
            border-left: 4px solid #555;
        }
        
        .nav-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        /* Formel-Erklärung mit gleichem Stil */
        .formula-explanation {
            margin-top: 10px; /* Reduzierter Abstand */
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 8px;
            border-left: 4px solid #555;
            font-size: 13px;
            max-height: 150px; /* Maximale Höhe begrenzen */
            overflow-y: auto;
        }
        
        .formula-explanation h3 {
            margin-top: 0;
            margin-bottom: 6px;
            color: #333;
            font-size: 15px;
        }
        
        .formula-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }
        
        .formula-button {
            padding: 4px 8px;
            background-color: #444; /* Dunklerer Hintergrund */
            border: 1px solid #333;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            color: white; /* Weiße Schrift für besseren Kontrast */
            font-weight: bold; /* Fett für bessere Lesbarkeit */
        }
        
        .formula-button:hover {
            background-color: #333;
        }
        
        .explanation-text {
            background-color: #f5f5f5; /* Hellerer Hintergrund für bessere Lesbarkeit */
            padding: 8px;
            border-radius: 4px;
            margin-top: 6px;
            font-size: 12px;
            border: 1px solid #ddd;
        }
        
        /* Responsives Design */
        @media (max-width: 768px) {
            .top-section {
                flex-direction: column;
            }
            
            .categories-grid {
                grid-template-columns: 1fr;
            }
            
            .search-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .nav-buttons {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="top-section">
            <!-- Linke Seite: Suche -->
            <div class="search-section">
                <header>
                    <h1>Sense - Verbanwendung</h1>
                    <p>Durchsuchen Sie deutsche Verben und deren SENSE-Kodierungen</p>
                </header>
                
                <div class="search-container">
                    <input type="text" id="searchInput" placeholder="Verb eingeben..." autocomplete="off">
                    <button id="searchButton">Suchen</button>
                    <div class="search-hint">Bitte geben Sie deutsche Verben ein (enden auf -en, -eln oder -ern).</div>
                </div>
                
                <div id="errorMessage" class="error-message" style="display: none;"></div>
                <div id="suggestions" class="suggestion" style="display: none;"></div>
            </div>
            
            <!-- Rechte Seite: Kategorien -->
            <div class="categories-section">
                <div class="categories-title">Thematische Bereiche</div>
                <div class="categories-grid">
                    <button class="category-button" data-category="auseinandersetzung">Auseinandersetzung</button>
                    <button class="category-button" data-category="behoerden">Behörden</button>
                    <button class="category-button" data-category="business">Business</button>
                    <button class="category-button" data-category="computer">Computer</button>
                    <button class="category-button" data-category="disput">Disput</button>
                    <button class="category-button" data-category="forschung">Forschung</button>
                    <button class="category-button" data-category="it">IT</button>
                    <button class="category-button" data-category="konflikte">Konflikte</button>
                    <button class="category-button" data-category="koerperlichkeiten">Körperlichkeiten</button>
                    <button class="category-button" data-category="kriminalitaet">Kriminalität</button>
                    <button class="category-button" data-category="mahlzeiten">Mahlzeiten</button>
                    <button class="category-button" data-category="materielles">Materielles</button>
                    <button class="category-button" data-category="psychologie">Psychologie</button>
                    <button class="category-button" data-category="sport">Sport</button>
                    <button class="category-button" data-category="streit">Streit</button>
                </div>
            </div>
        </div>
        
        <!-- Anzeigebereich für das aktuelle Verb -->
        <div class="display-area" id="displayArea">
            <div class="verb-heading" id="currentVerb">Lädt...</div>
            <div class="verb-info" id="verbInfo">Lädt...</div>
            <div class="code-display" id="codeDisplay">Lädt Kodierung...</div>
            <div class="explanation" id="explanationDisplay">Lädt Begründung...</div>
            <div class="alternatives" id="alternativesArea" style="display: none;"></div>
        </div>
        
        <!-- Navigation direkt unter dem Display-Bereich -->
        <div class="navigation">
            <div class="nav-buttons">
                <button id="firstButton">Erste Seite</button>
                <button id="prevButton">Zurück</button>
                <button id="nextButton">Weiter</button>
                <button id="lastButton">Letzte Seite</button>
            </div>
        </div>
        
        <!-- Erklärungssektion für Formel-Zusätze -->
        <div class="formula-explanation">
            <h3>Erklärung von Formel-Zusätzen</h3>
            <div class="formula-buttons">
                <button class="formula-button" data-formula="slash">//</button>
                <button class="formula-button" data-formula="adj">ADJ</button>
                <button class="formula-button" data-formula="wish">WISH/</button>
                <button class="formula-button" data-formula="no">NO/</button>
                <button class="formula-button" data-formula="not">NOT/</button>
                <button class="formula-button" data-formula="cp">CP/</button>
                <button class="formula-button" data-formula="anti">ANTI/</button>
            </div>
            <div id="explanationText" class="explanation-text" style="display: none;"></div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Variablen für die Verarbeitung
            let verbEntries = [];
            let uniqueVerbs = []; // Liste der einzigartigen Verben (alphabetisch)
            let currentIndex = 0;
            let searchTimeout;
            let lastSearchTerm = '';
            
            // NEU: Für Kategorien
            let currentCategoryVerbs = [];
            let isInCategoryMode = false;
            
            // NEU: Kategorie-Datenbank
            const categoryVerbs = {
                auseinandersetzung: ["abwehren", "angreifen", "aufbegehren", "bekämpfen", "beleidigen", "drohen", "kämpfen", "protestieren", "streiten", "verteidigen", "widersprechen"],
                behoerden: ["anmelden", "beantragen", "genehmigen", "melden", "registrieren", "verbieten", "verwalten", "zulassen"],
                business: ["anbieten", "arbeiten", "beschäftigen", "bestellen", "handeln", "investieren", "kaufen", "produzieren", "verkaufen", "vermitteln", "werben"],
                computer: ["abspeichern", "ausdrucken", "booten", "drucken", "formatieren", "hochfahren", "installieren", "programmieren", "scannen", "speichern"],
                disput: ["argumentieren", "debattieren", "diskutieren", "kritisieren", "streiten", "widerlegen", "widersprechen"],
                forschung: ["analysieren", "aufzeichnen", "dokumentieren", "erforschen", "experimentieren", "forschen", "messen", "testen", "untersuchen"],
                it: ["booten", "coden", "debuggen", "formatieren", "installieren", "programmieren", "scannen", "speichern"],
                konflikte: ["angreifen", "bekämpfen", "kämpfen", "streiten", "verteidigen", "widersprechen"],
                koerperlichkeiten: ["atmen", "fühlen", "gehen", "hören", "laufen", "riechen", "schmecken", "sehen", "schwimmen", "springen", "tasten"],
                kriminalitaet: ["betrügen", "erpressen", "fälschen", "klauen", "rauben", "schmuggeln", "stehlen", "unterschlagen"],
                mahlzeiten: ["backen", "braten", "essen", "grillen", "kochen", "schmecken", "trinken", "würzen"],
                materielles: ["aufbewahren", "bauen", "besitzen", "entsorgen", "erwerben", "kaufen", "verkaufen", "verstecken"],
                psychologie: ["denken", "empfinden", "erinnern", "fühlen", "hoffen", "träumen", "vergessen", "verstehen", "wünschen"],
                sport: ["gewinnen", "joggen", "laufen", "schwimmen", "spielen", "trainieren", "turnen", "verlieren", "wettkämpfen"],
                streit: ["anschreien", "beleidigen", "beschimpfen", "fluchen", "schimpfen", "streiten", "zanken"]
            };
            
            // NEU: Erklärungstexte für Formel-Zusätze
            const explanations = {
                slash: "// (Doppelter Schrägstrich) markiert den Wechsel zwischen den Goals des Akteurs und des Antagonisten. Nach "4" folgen Goals für den Antagonisten, nach // folgen wieder Goals für den Akteur.",
                adj: "ADJ steht für 'Adjektiv' und kennzeichnet die Eigenschaftsform einer Aktivität. Beispiel: 'machbar' = ADJ 3/Goal 2/aut/ecc.",
                wish: "WISH/ als Prefix zeigt an, dass eine Aktivität vom Akteur gewünscht wird, aber noch nicht ausgeführt wurde.",
                no: "NO/ als Prefix zeigt an, dass vor der Ausführung einer Aktivität feststeht, dass sie nicht zum Goal führen wird, oder dass ein benötigtes Objekt fehlt.",
                not: "NOT/ als Prefix zeigt an, dass sich bei einer Aktivität herausstellt, dass das Goal nicht erreicht werden kann oder nicht erreicht werden soll.",
                cp: "CP/ (Change Position) bedeutet, dass der Code sich auf den Antagonisten bezieht und der Akteur die Folgen der Handlung des Antagonisten erleidet.",
                anti: "ANTI/ als Prefix bedeutet, dass genau das Gegenteil der nachfolgenden Kodierung gemeint ist."
            };
            
            // DOM-Elemente
            const searchInput = document.getElementById('searchInput');
            const searchButton = document.getElementById('searchButton');
            const errorMessage = document.getElementById('errorMessage');
            const suggestions = document.getElementById('suggestions');
            const displayArea = document.getElementById('displayArea');
            const currentVerb = document.getElementById('currentVerb');
            const verbInfo = document.getElementById('verbInfo');
            const codeDisplay = document.getElementById('codeDisplay');
            const explanationDisplay = document.getElementById('explanationDisplay');
            const alternativesArea = document.getElementById('alternativesArea');
            const firstButton = document.getElementById('firstButton');
            const prevButton = document.getElementById('prevButton');
            const nextButton = document.getElementById('nextButton');
            const lastButton = document.getElementById('lastButton');
            
            // NEU: Zusätzliche DOM-Elemente für Kategorien und Formeln
            const categoryButtons = document.querySelectorAll('.category-button');
            const formulaButtons = document.querySelectorAll('.formula-button');
            const explanationText = document.getElementById('explanationText');
            
            // CSS-Anpassungen
            currentVerb.style.color = 'black'; // Überschrift schwarz statt blau
            
            // NEU: Event-Listener für Formel-Buttons
            formulaButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const formula = this.getAttribute('data-formula');
                    
                    // Aktiven Zustand für alle Buttons zurücksetzen
                    formulaButtons.forEach(btn => {
                        btn.style.backgroundColor = '#444';
                    });
                    
                    // Diesen Button hervorheben
                    this.style.backgroundColor = '#222';
                    
                    if (formula && explanations[formula]) {
                        explanationText.textContent = explanations[formula];
                        explanationText.style.display = 'block';
                    } else {
                        explanationText.style.display = 'none';
                    }
                });
            });
            
            // NEU: Event-Listener für Kategorie-Buttons
            categoryButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const category = this.getAttribute('data-category');
                    
                    // Alle Buttons zurücksetzen
                    categoryButtons.forEach(btn => btn.classList.remove('active'));
                    
                    // Diesen Button als aktiv markieren
                    this.classList.add('active');
                    
                    // Kategorie-Verben laden
                    if (category && categoryVerbs[category] && categoryVerbs[category].length > 0) {
                        loadCategoryVerbs(category);
                    } else {
                        showError(`Keine Verben für die Kategorie "${this.textContent}" gefunden.`);
                    }
                });
            });
            
            // WICHTIG: Unverändert aus der funktionierenden Version
            fetch('Coded_Verbs.txt')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Datei konnte nicht geladen werden');
                    }
                    return response.text();
                })
                .then(text => {
                    processVerbFile(text);
                    displayEntry(0);
                    updateNavButtons();
                })
                .catch(error => {
                    showError('Die Datei "Coded_Verbs.txt" konnte nicht geladen werden. Bitte stellen Sie sicher, dass sie im selben Verzeichnis wie diese HTML-Datei liegt.');
                });
            
            // WICHTIG: Unverändert aus der funktionierenden Version    
            function processVerbFile(text) {
                console.log("Verarbeite Datei...");
                
                // Teile den Text in Blöcke auf (Leerzeilen als Trenner)
                const blocks = text.split(/\n\s*\n/);
                console.log(`Gefundene Textblöcke: ${blocks.length}`);
                
                // Temporäres Array für die Einträge
                let tempEntries = [];
                
                // Verarbeite jeden Block (ein Block = ein Eintrag mit Begründung)
                for (let blockIndex = 0; blockIndex < blocks.length; blockIndex++) {
                    const block = blocks[blockIndex].trim();
                    if (!block) continue; // Leere Blöcke überspringen
                    
                    const lines = block.split('\n');
                    
                    // Finde die Verb-Zeile (sollte die erste sein)
                    let verbLine = null;
                    let explanationLine = null;
                    
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;
                        
                        if (line.startsWith('Begründung:')) {
                            explanationLine = line;
                        } else if (line.includes(':')) {
                            verbLine = line;
                        }
                    }
                    
                    if (verbLine) {
                        const colonPos = verbLine.indexOf(':');
                        const verb = verbLine.substring(0, colonPos).trim();
                        const code = verbLine.substring(colonPos + 1).trim();
                        
                        // Extrahiere die Begründung, falls vorhanden
                        let explanation = "";
                        if (explanationLine) {
                            explanation = explanationLine.substring('Begründung:'.length).trim();
                        }
                        
                        // Füge den Eintrag hinzu
                        tempEntries.push({
                            verb: verb,
                            code: code,
                            explanation: explanation,
                            blockIndex: blockIndex // Für die Sortierung
                        });
                    }
                }
                
                // Gruppiere nach Verb und nummeriere
                const verbGroups = {};
                tempEntries.forEach(entry => {
                    if (!verbGroups[entry.verb]) {
                        verbGroups[entry.verb] = [];
                    }
                    verbGroups[entry.verb].push(entry);
                });
                
                // Erstelle die finale Liste mit Bedeutungsnummern
                verbEntries = [];
                uniqueVerbs = Object.keys(verbGroups).sort();
                
                uniqueVerbs.forEach((verb, verbIndex) => {
                    // Sortiere nach der ursprünglichen Reihenfolge im Text
                    const sortedEntries = verbGroups[verb].sort((a, b) => a.blockIndex - b.blockIndex);
                    
                    // Füge Bedeutungsnummern hinzu
                    sortedEntries.forEach((entry, index) => {
                        verbEntries.push({
                            verb: entry.verb,
                            code: entry.code,
                            explanation: entry.explanation,
                            meaningNumber: index + 1,
                            totalMeanings: sortedEntries.length,
                            verbIndex: verbIndex + 1 // 1-basierter Index des Verbs in der alphabetischen Liste
                        });
                    });
                });
                
                console.log("Verarbeitung abgeschlossen");
                console.log(`Gefundene Einträge: ${verbEntries.length}`);
                console.log(`Einzigartige Verben: ${uniqueVerbs.length}`);
                
                if (verbEntries.length > 0) {
                    console.log("Erster Eintrag:", verbEntries[0]);
                }
            }
            
            // NEU: Funktion zum Laden von Kategorien
            function loadCategoryVerbs(category) {
                const verbs = categoryVerbs[category];
                
                if (!verbs || verbs.length === 0) {
                    showError(`Keine Verben für diese Kategorie gefunden.`);
                    return;
                }
                
                // Filter nur Verben, die tatsächlich in unserer Datenbank sind
                const availableCategoryVerbs = [];
                
                // Finde die Indizes der Verben dieser Kategorie
                verbs.forEach(verb => {
                    const index = verbEntries.findIndex(entry => 
                        entry.verb.toLowerCase() === verb.toLowerCase() && entry.meaningNumber === 1
                    );
                    
                    if (index !== -1) {
                        availableCategoryVerbs.push(index);
                    }
                });
                
                if (availableCategoryVerbs.length === 0) {
                    showError(`Keine passenden Verben in der Datenbank für diese Kategorie gefunden.`);
                    return;
                }
                
                // Speichere die Kategorie-Verben und zeige das erste an
                currentCategoryVerbs = availableCategoryVerbs;
                isInCategoryMode = true;
                
                // Zeige das erste Verb der Kategorie an
                displayEntry(availableCategoryVerbs[0]);
                updateNavButtons();
                
                // Hinweis zeigen
                const activeCategory = document.querySelector('.category-button.active');
                const categoryName = activeCategory ? activeCategory.textContent : category;
                verbInfo.textContent = `Kategorie: ${categoryName} | Verb 1 von ${availableCategoryVerbs.length} | ${verbEntries[availableCategoryVerbs[0]].meaningNumber}. Bedeutung von ${verbEntries[availableCategoryVerbs[0]].totalMeanings}`;
                
                hideError();
                hideSuggestions();
            }
            
            // Minimal angepasst für Kategorien
            function displayEntry(index) {
                if (index < 0 || index >= verbEntries.length) {
                    showError('Ungültiger Index: ' + index);
                    return;
                }
                
                const entry = verbEntries[index];
                currentIndex = index;
                
                // Verb anzeigen
                currentVerb.textContent = entry.verb;
                currentVerb.style.color = 'black'; // Schwarz statt Blau
                
                // Zusätzliche Informationen anzeigen
                if (isInCategoryMode) {
                    // Kategorie-Modus
                    const categoryIndex = currentCategoryVerbs.findIndex(idx => {
                        return verbEntries[idx].verb === entry.verb;
                    });
                    
                    if (categoryIndex !== -1) {
                        const activeCategory = document.querySelector('.category-button.active');
                        const categoryName = activeCategory ? activeCategory.textContent : 'Aktiv';
                        verbInfo.textContent = `Kategorie: ${categoryName} | Verb ${categoryIndex + 1} von ${currentCategoryVerbs.length} | ${entry.meaningNumber}. Bedeutung von ${entry.totalMeanings}`;
                    } else {
                        verbInfo.textContent = `Verb ${entry.verbIndex} von ${uniqueVerbs.length} | ${entry.meaningNumber}. Bedeutung von ${entry.totalMeanings}`;
                    }
                } else {
                    // Standard-Modus
                    verbInfo.textContent = `Verb ${entry.verbIndex} von ${uniqueVerbs.length} | ${entry.meaningNumber}. Bedeutung von ${entry.totalMeanings}`;
                }
                
                // Code anzeigen
                codeDisplay.textContent = entry.code;
                
                // Begründung anzeigen
                if (entry.explanation && entry.explanation.trim()) {
                    explanationDisplay.textContent = entry.explanation;
                    explanationDisplay.style.display = 'block';
                } else {
                    explanationDisplay.textContent = "Keine Begründung verfügbar";
                    explanationDisplay.style.display = 'block';
                }
                
                // Keine Alternativen mehr anzeigen, da jede Bedeutung einzeln dargestellt wird
                alternativesArea.style.display = 'none';
                
                // Fehler und Vorschläge zurücksetzen
                hideError();
                hideSuggestions();
            }
            
            // Minimal angepasst für Kategorien
            function searchVerb(term) {
                if (!term) {
                    hideSuggestions();
                    return;
                }
                
                term = term.toLowerCase().trim();
                
                // Zurück zum normalen Modus bei Suche
                isInCategoryMode = false;
                categoryButtons.forEach(btn => btn.classList.remove('active'));
                
                // Exakte Übereinstimmung suchen (erste Bedeutung)
                const exactMatch = verbEntries.findIndex(entry => 
                    entry.verb.toLowerCase() === term && entry.meaningNumber === 1
                );
                
                if (exactMatch !== -1) {
                    displayEntry(exactMatch);
                    hideError();
                    hideSuggestions();
                    return true;
                }
                
                // Suche nach Verben, die mit dem Suchbegriff beginnen (erste Bedeutung)
                const startsWith = verbEntries.findIndex(entry => 
                    entry.verb.toLowerCase().startsWith(term) && entry.meaningNumber === 1
                );
                
                if (startsWith !== -1) {
                    displayEntry(startsWith);
                    
                    // Zeige Vorschläge für ähnliche Verben
                    showSimilarVerbs(term);
                    return true;
                }
                
                // Teilübereinstimmung (erste Bedeutung)
                const partialMatch = verbEntries.findIndex(entry => 
                    entry.verb.toLowerCase().includes(term) && entry.meaningNumber === 1
                );
                
                if (partialMatch !== -1) {
                    displayEntry(partialMatch);
                    
                    // Zeige Vorschläge für ähnliche Verben
                    showSimilarVerbs(term);
                    return true;
                }
                
                // Wenn keine erste Bedeutung gefunden wurde, suche nach beliebiger Bedeutung
                const anyMatch = verbEntries.findIndex(entry => 
                    entry.verb.toLowerCase().includes(term)
                );
                
                if (anyMatch !== -1) {
                    displayEntry(anyMatch);
                    showSimilarVerbs(term);
                    return true;
                }
                
                // Keine Übereinstimmung gefunden
                showError(`Das Verb "${term}" wurde nicht gefunden. Möglicherweise ist es nicht in unserer Datenbank enthalten oder anders geschrieben.`);
                showSimilarVerbs(term);
                return false;
            }
            
            // Unverändert aus funktionierendem Code
            function showSimilarVerbs(term) {
                if (!term || term.length < 2) {
                    hideSuggestions();
                    return;
                }
                
                // Finde einzigartige Verben (keine Duplikate wegen mehrerer Bedeutungen)
                const similarVerbs = uniqueVerbs
                    .filter(verb => verb.toLowerCase().includes(term.toLowerCase()))
                    .slice(0, 5);  // Begrenze auf 5 Vorschläge
                
                if (similarVerbs.length > 0) {
                    suggestions.innerHTML = 'Ähnliche Verben: ' + 
                        similarVerbs.map(verb => `<a href="#" class="verb-suggestion">${verb}</a>`).join(', ');
                    suggestions.style.display = 'block';
                    
                    // Event-Listener für Vorschläge
                    document.querySelectorAll('.verb-suggestion').forEach(link => {
                        link.addEventListener('click', function(e) {
                            e.preventDefault();
                            const selectedVerb = this.textContent;
                            searchInput.value = selectedVerb;
                            searchVerb(selectedVerb);
                        });
                    });
                } else {
                    hideSuggestions();
                }
            }
            
            // Unverändert aus funktionierendem Code
            function isValidGermanVerb(text) {
                // Vereinfachte Prüfung: ein deutsches Verb endet typischerweise auf -en, -eln, -ern
                // und enthält keine Zahlen oder Sonderzeichen (außer ä, ö, ü, ß)
                const germanVerbPattern = /^[a-zäöüß]+(?:en|eln|ern)$/i;
                
                return germanVerbPattern.test(text.trim());
            }
            
            // Unverändert aus funktionierendem Code
            function showError(message) {
                errorMessage.textContent = message;
                errorMessage.style.display = 'block';
            }
            
            // Unverändert aus funktionierendem Code
            function hideError() {
                errorMessage.style.display = 'none';
            }
            
            // Unverändert aus funktionierendem Code
            function hideSuggestions() {
                suggestions.style.display = 'none';
            }
            
            // Angepasst für Kategorien
            function updateNavButtons() {
                if (isInCategoryMode) {
                    // Kategorie-Modus: Besondere Logik
                    const currentEntry = verbEntries[currentIndex];
                    
                    // Bestimme, ob es vorherige/nachfolgende Bedeutungen gibt
                    const hasPrevMeaning = currentEntry.meaningNumber > 1;
                    const hasNextMeaning = currentEntry.meaningNumber < currentEntry.totalMeanings;
                    
                    // Bestimme die Position des aktuellen Verbs in der Kategorie-Liste
                    let verbInCategory = -1;
                    for (let i = 0; i < currentCategoryVerbs.length; i++) {
                        const categoryVerbEntry = verbEntries[currentCategoryVerbs[i]];
                        if (categoryVerbEntry.verb === currentEntry.verb) {
                            verbInCategory = i;
                            break;
                        }
                    }
                    
                    // Prüfe, ob wir das erste/letzte Verb in der Kategorie haben
                    const isFirstVerb = verbInCategory === 0 && !hasPrevMeaning;
                    const isLastVerb = verbInCategory === currentCategoryVerbs.length - 1 && !hasNextMeaning;
                    
                    prevButton.disabled = isFirstVerb;
                    firstButton.disabled = isFirstVerb;
                    nextButton.disabled = isLastVerb;
                    lastButton.disabled = isLastVerb;
                } else {
                    // Standard-Modus: Wie bisher
                    prevButton.disabled = currentIndex <= 0;
                    firstButton.disabled = currentIndex <= 0;
                    nextButton.disabled = currentIndex >= verbEntries.length - 1;
                    lastButton.disabled = currentIndex >= verbEntries.length - 1;
                }
            }
            
            // Angepasst für Kategorien
            function goToNext() {
                if (isInCategoryMode) {
                    // Im Kategoriemodus
                    const currentEntry = verbEntries[currentIndex];
                    
                    // Erst durch alle Bedeutungen dieses Verbs, dann zum nächsten Verb
                    if (currentEntry.meaningNumber < currentEntry.totalMeanings) {
                        // Zur nächsten Bedeutung
                        for (let i = currentIndex + 1; i < verbEntries.length; i++) {
                            if (verbEntries[i].verb === currentEntry.verb) {
                                displayEntry(i);
                                break;
                            }
                        }
                    } else {
                        // Zum nächsten Verb in der Kategorie
                        let currentVerbInCategory = -1;
                        
                        for (let i = 0; i < currentCategoryVerbs.length; i++) {
                            const idx = currentCategoryVerbs[i];
                            if (verbEntries[idx].verb === currentEntry.verb) {
                                currentVerbInCategory = i;
                                break;
                            }
                        }
                        
                        if (currentVerbInCategory >= 0 && currentVerbInCategory < currentCategoryVerbs.length - 1) {
                            displayEntry(currentCategoryVerbs[currentVerbInCategory + 1]);
                        }
                    }
                } else {
                    // Im Standard-Modus: Wie bisher
                    if (currentIndex < verbEntries.length - 1) {
                        displayEntry(currentIndex + 1);
                    }
                }
                updateNavButtons();
            }
            
            // Angepasst für Kategorien
            function goToPrevious() {
                if (isInCategoryMode) {
                    // Im Kategoriemodus
                    const currentEntry = verbEntries[currentIndex];
                    
                    // Erst durch alle vorherigen Bedeutungen, dann zum vorherigen Verb
                    if (currentEntry.meaningNumber > 1) {
                        // Zur vorherigen Bedeutung
                        for (let i = currentIndex - 1; i >= 0; i--) {
                            if (verbEntries[i].verb === currentEntry.verb) {
                                displayEntry(i);
                                break;
                            }
                        }
                    } else {
                        // Zum vorherigen Verb in der Kategorie
                        let currentVerbInCategory = -1;
                        
                        for (let i = 0; i < currentCategoryVerbs.length; i++) {
                            const idx = currentCategoryVerbs[i];
                            if (verbEntries[idx].verb === currentEntry.verb) {
                                currentVerbInCategory = i;
                                break;
                            }
                        }
                        
                        if (currentVerbInCategory > 0) {
                            // Zum vorherigen Verb, letzte Bedeutung
                            const prevVerbIndex = currentCategoryVerbs[currentVerbInCategory - 1];
                            const prevVerb = verbEntries[prevVerbIndex].verb;
                            
                            let lastMeaningIndex = prevVerbIndex;
                            for (let i = 0; i < verbEntries.length; i++) {
                                if (verbEntries[i].verb === prevVerb) {
                                    lastMeaningIndex = Math.max(lastMeaningIndex, i);
                                }
                            }
                            
                            displayEntry(lastMeaningIndex);
                        }
                    }
                } else {
                    // Im Standard-Modus: Wie bisher
                    if (currentIndex > 0) {
                        displayEntry(currentIndex - 1);
                    }
                }
                updateNavButtons();
            }
            
            // Event-Listener registrieren
            
            // Live-Suche mit Timeout
            searchInput.addEventListener('input', function() {
                const term = this.value.trim();
                
                // Ignoriere kurze Eingaben für die Live-Suche
                if (term.length < 2) {
                    hideSuggestions();
                    return;
                }
                
                // Setze früheren Timeout zurück
                clearTimeout(searchTimeout);
                
                // Warte kurz, bevor die Suche durchgeführt wird
                searchTimeout = setTimeout(() => {
                    if (term !== lastSearchTerm) {
                        searchVerb(term);
                        lastSearchTerm = term;
                    }
                }, 300);
            });
            
            // Such-Button
            searchButton.addEventListener('click', function() {
                const term = searchInput.value.trim();
                
                if (!term) {
                    showError('Bitte geben Sie ein Verb ein.');
                    return;
                }
                
                if (!isValidGermanVerb(term) && term.length > 2) {
                    showError('Bitte geben Sie ein gültiges deutsches Verb ein (endet typischerweise auf -en, -eln oder -ern).');
                    return;
                }
                
                searchVerb(term);
            });
            
            // Navigationstasten
            prevButton.addEventListener('click', function() {
                goToPrevious();
            });
            
            nextButton.addEventListener('click', function() {
                goToNext();
            });
            
            // Angepasst für Kategorien
            firstButton.addEventListener('click', function() {
                if (isInCategoryMode) {
                    // Zum ersten Verb der Kategorie
                    displayEntry(currentCategoryVerbs[0]);
                } else {
                    // Zum absolut ersten Verb
                    displayEntry(0);
                }
                updateNavButtons();
            });
            
            // Angepasst für Kategorien
            lastButton.addEventListener('click', function() {
                if (isInCategoryMode) {
                    // Zum letzten Verb der Kategorie (letzte Bedeutung)
                    const lastCategoryVerbIndex = currentCategoryVerbs[currentCategoryVerbs.length - 1];
                    const lastVerb = verbEntries[lastCategoryVerbIndex].verb;
                    
                    // Finde den Index der letzten Bedeutung des letzten Verbs
                    let lastMeaningIndex = lastCategoryVerbIndex;
                    for (let i = 0; i < verbEntries.length; i++) {
                        if (verbEntries[i].verb === lastVerb) {
                            lastMeaningIndex = Math.max(lastMeaningIndex, i);
                        }
                    }
                    
                    displayEntry(lastMeaningIndex);
                } else {
                    // Zum absolut letzten Verb
                    displayEntry(verbEntries.length - 1);
                }
                updateNavButtons();
            });
            
            // Tastatur-Navigation
            document.addEventListener('keydown', function(e) {
                if (e.target === searchInput) {
                    // Wenn im Suchfeld, nur bei Enter-Taste suchen
                    if (e.key === 'Enter') {
                        const term = searchInput.value.trim();
                        if (term) {
                            searchVerb(term);
                        }
                    }
                    return;
                }
                
                // Sonst allgemeine Navigation
                switch (e.key) {
                    case 'ArrowLeft':
                        goToPrevious();
                        break;
                    case 'ArrowRight':
                        goToNext();
                        break;
                    case 'Home':
                        if (isInCategoryMode) {
                            displayEntry(currentCategoryVerbs[0]);
                        } else {
                            displayEntry(0);
                        }
                        updateNavButtons();
                        break;
                    case 'End':
                        if (isInCategoryMode) {
                            const lastCategoryVerbIndex = currentCategoryVerbs[currentCategoryVerbs.length - 1];
                            const lastVerb = verbEntries[lastCategoryVerbIndex].verb;
                            
                            let lastMeaningIndex = lastCategoryVerbIndex;
                            for (let i = 0; i < verbEntries.length; i++) {
                                if (verbEntries[i].verb === lastVerb) {
                                    lastMeaningIndex = Math.max(lastMeaningIndex, i);
                                }
                            }
                            
                            displayEntry(lastMeaningIndex);
                        } else {
                            displayEntry(verbEntries.length - 1);
                        }
                        updateNavButtons();
                        break;
                }
            });
        });
    </script>
</body>
</html>